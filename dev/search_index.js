var documenterSearchIndex = {"docs":
[{"location":"benchmarks/#Benchmarks","page":"Benchmarks","title":"Benchmarks","text":"","category":"section"},{"location":"benchmarks/","page":"Benchmarks","title":"Benchmarks","text":"using BenchmarkTools, ItPropFit, Logging\nLogging.disable_logging(Logging.Info)","category":"page"},{"location":"benchmarks/","page":"Benchmarks","title":"Benchmarks","text":"The benchmarks below were run on Julia 1.7.2.","category":"page"},{"location":"benchmarks/#Default-example","page":"Benchmarks","title":"Default example","text":"","category":"section"},{"location":"benchmarks/","page":"Benchmarks","title":"Benchmarks","text":"X = [40 30 20 10; 35 50 100 75; 30 80 70 120; 20 30 40 50]\nu = [150, 300, 400, 150]\nv = [200, 300, 400, 100]\n@benchmark ipf(X, [u, v])","category":"page"},{"location":"benchmarks/","page":"Benchmarks","title":"Benchmarks","text":"Range (min … max):  140.900 μs …   4.671 ms  ┊ GC (min … max): 0.00% … 95.78%\nTime  (median):     152.100 μs               ┊ GC (median):    0.00%\nTime  (mean ± σ):   166.711 μs ± 170.558 μs  ┊ GC (mean ± σ):  4.01% ±  3.82%","category":"page"},{"location":"benchmarks/#Large-contingency-table","page":"Benchmarks","title":"Large contingency table","text":"","category":"section"},{"location":"benchmarks/","page":"Benchmarks","title":"Benchmarks","text":"X = reshape(repeat(1:16, 625), 100, 100)\nY = reshape(repeat(1:5, 2000), 100, 100) + X\nm = margins(Y)\n@benchmark ipf(X, m)","category":"page"},{"location":"benchmarks/","page":"Benchmarks","title":"Benchmarks","text":"Range (min … max):  1.319 ms …   5.078 ms  ┊ GC (min … max): 0.00% … 47.57%\nTime  (median):     1.483 ms               ┊ GC (median):    0.00%\nTime  (mean ± σ):   1.699 ms ± 518.851 μs  ┊ GC (mean ± σ):  7.66% ± 13.26%","category":"page"},{"location":"benchmarks/#Six-dimensional-contingency-table","page":"Benchmarks","title":"Six-dimensional contingency table","text":"","category":"section"},{"location":"benchmarks/","page":"Benchmarks","title":"Benchmarks","text":"X = reshape(repeat(1:12, 100), 6, 4, 2, 5, 5)\nY = reshape(repeat(1:5, 240), 6, 4, 2, 5, 5) + X\nm = margins(Y)\n@benchmark ipf(X, m)","category":"page"},{"location":"benchmarks/","page":"Benchmarks","title":"Benchmarks","text":"Range (min … max):  163.341 ms … 195.328 ms  ┊ GC (min … max): 2.67% … 2.66%\nTime  (median):     171.324 ms               ┊ GC (median):    2.51%\nTime  (mean ± σ):   172.793 ms ±   7.910 ms  ┊ GC (mean ± σ):  2.65% ± 0.44%","category":"page"},{"location":"reference/","page":"Reference","title":"Reference","text":"CurrentModule = ItPropFit","category":"page"},{"location":"reference/#Reference","page":"Reference","title":"Reference","text":"","category":"section"},{"location":"reference/","page":"Reference","title":"Reference","text":"","category":"page"},{"location":"reference/","page":"Reference","title":"Reference","text":"Modules = [ItPropFit]","category":"page"},{"location":"reference/#Core.Array-Union{Tuple{ArrayFactors{T}}, Tuple{T}} where T","page":"Reference","title":"Core.Array","text":"Array(A::ArrayFactors{T})\n\nCreate an array out of an ArrayFactors object.\n\nArguments\n\nA::ArrayFactors{T}: Array factors\n\nExamples\n\njulia> fac = ArrayFactors([[1,2,3], [4,5], [6,7]])\nFactors for array of size (3, 2, 2):\n    1: [1, 2, 3]\n    2: [4, 5]\n    3: [6, 7]\n\njulia> Array(fac)\n3×2×2 Array{Int64, 3}:\n[:, :, 1] =\n 24  30\n 48  60\n 72  90\n\n[:, :, 2] =\n 28   35\n 56   70\n 84  105\n\n\n\n\n\n","category":"method"},{"location":"reference/#ItPropFit.ArrayFactors","page":"Reference","title":"ItPropFit.ArrayFactors","text":"ArrayFactors(f)\n\nArray factors are defined such that the array's elements are their products: M[i, j, ..., l] = f[1][i] * f[2][j] * ... * f[3][l]\n\nsee also: ipf, margins, Array\n\nFields\n\nf::Vector{Vector{T}}: Vector of array factors\n\nExamples\n\njulia> AF = ArrayFactors([[1,2,3], [4,5]])\nFactors for array of size (3, 2):\n  1: [1, 2, 3]\n  2: [4, 5]\n\njulia> eltype(AF)\nInt64\n\njulia> Array(AF)\n3×2 Matrix{Int64}:\n  4   5\n  8  10\n 12  15\n\n\n\n\n\n","category":"type"},{"location":"reference/#ItPropFit.ipf-Tuple{AbstractArray{<:Real}, Vector{<:Vector{<:Real}}}","page":"Reference","title":"ItPropFit.ipf","text":"ipf(X, mar[; maxiter, tol])\n\nPerform iterative proportional fitting (factor method). The array (X) can be any number of dimensions, as long as the margins have the correct size. Will return the weights as an ArrayFactors object. \n\nsee also: ArrayFactors, margins\n\nArguments\n\nX::AbstractArray{<:Real}: Array to be adjusted\nmar::Vector{<:Vector{<:Real}}: Target margins\nmaxiter::Int=1000: Maximum number of iterations\ntol::Float64=1e-10: Factor change tolerance for convergence\n\nExamples\n\njulia> X = [40 30 20 10; 35 50 100 75; 30 80 70 120; 20 30 40 50]\njulia> u = [150, 300, 400, 150]\njulia> v = [200, 300, 400, 100]\njulia> AF = ipf(X, [u, v])\nFactors for array of size (4, 4):\n    1: [1.2513914546748504, 1.1069369933423092, 1.4659850061977997, 1.1146335537777001]\n    2: [1.2897345098410427, 1.2314947369488765, 1.4137981417470917, 0.305638354490167]\n\njulia> Array(AF) .* X\n4×4 Matrix{Float64}:\n 64.5585   46.2325   35.3843   3.82473\n 49.9679   68.1594  156.499   25.3742\n 56.7219  144.428   145.082   53.7673\n 28.7516   41.18     63.0347  17.0337\n\n\n\n\n\n","category":"method"},{"location":"reference/#ItPropFit.margins-Tuple{AbstractArray{<:Real}}","page":"Reference","title":"ItPropFit.margins","text":"margins(X)\n\nCompute the marginal sum totals for an array.\n\nArguments\n\nX::AbstractArray{<: Number}: array with any number of dimensions\n\nExamples\n\njulia> margins(reshape(1:12, 2, 3, 2))\n3-element Vector{Vector{Int64}}:\n [36, 42]\n [18, 26, 34]\n [21, 57]\n\n\n\n\n\n","category":"method"},{"location":"#ItPropFit","page":"Home","title":"ItPropFit","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Multidimensional iterative proportional fitting in Julia. ","category":"page"},{"location":"","page":"Home","title":"Home","text":"ItPropFit implements a multidimensional version of the factor estimation method for performing iterative proportional fitting (also called RAS algorithm, raking, matrix scaling). ","category":"page"},{"location":"","page":"Home","title":"Home","text":"In the two-dimensional case, iterative proportional fitting means changing a matrix X to have marginal sum totals u v. One prime use is in survey data analysis, where X could be your data's cross-tabulation of demographic characteristics, and u v the known population proportions of those characteristics.","category":"page"},{"location":"#Getting-started","page":"Home","title":"Getting started","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Assume you have a matrix X:","category":"page"},{"location":"","page":"Home","title":"Home","text":"X = [40 30 20 10; 35 50 100 75; 30 80 70 120; 20 30 40 50]","category":"page"},{"location":"","page":"Home","title":"Home","text":"4×4 Matrix{Int64}:\n 40  30   20   10\n 35  50  100   75\n 30  80   70  120\n 20  30   40   50","category":"page"},{"location":"","page":"Home","title":"Home","text":"And the row and column margins of another matrix Y (u and v, respectively) but not the full matrix:","category":"page"},{"location":"","page":"Home","title":"Home","text":"u = [150, 300, 400, 150]\nv = [200, 300, 400, 100]","category":"page"},{"location":"","page":"Home","title":"Home","text":"Then the ipf function from ItPropFit will find the array factors which adjust matrix X to have the margins u and v:","category":"page"},{"location":"","page":"Home","title":"Home","text":"fac = ipf(X, [u, v])","category":"page"},{"location":"","page":"Home","title":"Home","text":"[ Info: Converged in 8 iterations.\nFactors for array of size (4, 4):\n  1: [0.9986403503185242, 0.8833622306385376, 1.1698911437112522, 0.8895042701910321]\n  2: [1.616160156063788, 1.5431801747375655, 1.771623700829941, 0.38299396265192226]","category":"page"},{"location":"","page":"Home","title":"Home","text":"Array factors (ArrayFactors) are a specific type exported by ItPropFit with a few methods, for example Array():","category":"page"},{"location":"","page":"Home","title":"Home","text":"Array(fac)","category":"page"},{"location":"","page":"Home","title":"Home","text":"4×4 Matrix{Float64}:\n 1.61396  1.54108  1.76921  0.382473\n 1.42765  1.36319  1.56499  0.338322\n 1.89073  1.80535  2.07261  0.448061\n 1.43758  1.37267  1.57587  0.340675","category":"page"},{"location":"","page":"Home","title":"Home","text":"To create the adjusted matrix Z with the margins u and v, we perform elementwise multiplication of this matrix with X:","category":"page"},{"location":"","page":"Home","title":"Home","text":"Z = Array(AF) .* X","category":"page"},{"location":"","page":"Home","title":"Home","text":"4×4 Matrix{Float64}:\n 64.5585   46.2325   35.3843   3.82473\n 49.9679   68.1594  156.499   25.3742\n 56.7219  144.428   145.082   53.7673\n 28.7516   41.18     63.0347  17.0337","category":"page"},{"location":"","page":"Home","title":"Home","text":"We can then check that the marginal sum totals are correct:","category":"page"},{"location":"","page":"Home","title":"Home","text":"margins(Z)","category":"page"},{"location":"","page":"Home","title":"Home","text":"2-element Vector{Vector{Float64}}:\n [150.0000000009452, 299.99999999962523, 399.99999999949796, 149.99999999993148]\n [200.0, 299.99999999999994, 399.99999999999994, 99.99999999999997]","category":"page"},{"location":"#Multidimensional-arrays","page":"Home","title":"Multidimensional arrays","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"ItPropFit can also deal with multidimensional arrays of arbitrary shape. For example, consider the following (3, 2, 3) array and target margins:","category":"page"},{"location":"","page":"Home","title":"Home","text":"X = reshape(1:12, 2, 3, 2)","category":"page"},{"location":"","page":"Home","title":"Home","text":"2×3×2 reshape(::UnitRange{Int64}, 2, 3, 2) with eltype Int64:\n[:, :, 1] =\n 1  3  5\n 2  4  6\n\n[:, :, 2] =\n 7   9  11\n 8  10  12","category":"page"},{"location":"","page":"Home","title":"Home","text":"m = [[48, 60], [28, 36, 44], [34, 74]]","category":"page"},{"location":"","page":"Home","title":"Home","text":"3-element Vector{Vector{Int64}}:\n [48, 60]\n [28, 36, 44]\n [34, 74]","category":"page"},{"location":"","page":"Home","title":"Home","text":"Now we can run ipf to compute the adjustment:","category":"page"},{"location":"","page":"Home","title":"Home","text":"fac = ipf(X, m)","category":"page"},{"location":"","page":"Home","title":"Home","text":"[ Info: Converged in 8 iterations.\nFactors for array of size (2, 3, 2):\n  1: [0.7012649814229596, 0.7413620380098563]\n  2: [1.59452605457307, 1.3830398765538434, 1.2753933840995484]\n  3: [1.6474060813606772, 1.2880517029245548]","category":"page"},{"location":"","page":"Home","title":"Home","text":"And we can create the adjusted array Z:","category":"page"},{"location":"","page":"Home","title":"Home","text":"Array(fac) .* X","category":"page"},{"location":"","page":"Home","title":"Home","text":"2×3×2 Array{Float64, 3}:\n[:, :, 1] =\n 1.84211  4.79335  7.36711\n 3.89487  6.75656  9.34601\n\n[:, :, 2] =\n 10.082   11.2433  12.6722\n 12.1811  13.2068  14.6147","category":"page"}]
}

var documenterSearchIndex = {"docs":
[{"location":"benchmarks/#Benchmarks","page":"Benchmarks","title":"Benchmarks","text":"","category":"section"},{"location":"benchmarks/","page":"Benchmarks","title":"Benchmarks","text":"using BenchmarkTools, ItPropFit, Logging\nLogging.disable_logging(Logging.Info)","category":"page"},{"location":"benchmarks/","page":"Benchmarks","title":"Benchmarks","text":"The benchmarks below were run on Julia 1.7.2.","category":"page"},{"location":"benchmarks/#Default-example","page":"Benchmarks","title":"Default example","text":"","category":"section"},{"location":"benchmarks/","page":"Benchmarks","title":"Benchmarks","text":"X = [40 30 20 10; 35 50 100 75; 30 80 70 120; 20 30 40 50]\nu = [150, 300, 400, 150]\nv = [200, 300, 400, 100]\n@benchmark ipf(X, [u, v])","category":"page"},{"location":"benchmarks/#Large-contingency-table","page":"Benchmarks","title":"Large contingency table","text":"","category":"section"},{"location":"benchmarks/","page":"Benchmarks","title":"Benchmarks","text":"X = reshape(repeat(1:16, 625), 100, 100)\nY = reshape(repeat(1:5, 2000), 100, 100) + X\nm = margins(Y)\n@benchmark ipf(X, m)","category":"page"},{"location":"benchmarks/#Six-dimensional-contingency-table","page":"Benchmarks","title":"Six-dimensional contingency table","text":"","category":"section"},{"location":"benchmarks/","page":"Benchmarks","title":"Benchmarks","text":"X = reshape(repeat(1:12, 100), 6, 4, 2, 5, 5)\nY = reshape(repeat(1:5, 240), 6, 4, 2, 5, 5) + X\nm = margins(Y)\n@benchmark ipf(X, m)","category":"page"},{"location":"examples/#Examples","page":"Examples","title":"Examples","text":"","category":"section"},{"location":"examples/#Regression-poststratification","page":"Examples","title":"Regression poststratification","text":"","category":"section"},{"location":"examples/","page":"Examples","title":"Examples","text":"# Weight calibration of linear regression estimates\nusing StatsKit, FreqTables, ItPropFit\n\n# Generate some data\nN = 100\np_sex = Categorical([0.49, 0.51])\np_edu = Categorical([0.1, 0.3, 0.4, 0.2])\np_age = Categorical([0.1, 0.3, 0.3, 0.2, 0.1])\np_inc = LogNormal(5, 3)\np_opn = Normal(0, 3)\ndf = DataFrame(\n    :sex => CategoricalArray([\"m\", \"f\"][rand(p_sex, N)]),\n    :edu => CategoricalArray([\"no\", \"lo\", \"med\", \"hi\"][rand(p_edu, N)], ordered = true),\n    :age => CategoricalArray([\"<10\", \"11<25\", \"26<50\", \"51<70\", \">70\"][rand(p_age, N)], ordered = true),\n    :inc => rand(p_inc, N)\n)\ndf.opn = df.inc .* .1 + rand(p_opn, N)\n\n# Create a cross-table of background characteristics\ntab = freqtable(df, :sex, :edu, :age)\n\n# Create margins from the population (aggregates obtained from statistical agency)\npop_margins = [[0.49, 0.51], [0.05, 0.2, 0.5, 0.25], [0.1, 0.2, 0.4, 0.15, 0.15]]\n\n# Compute array factors\nfac = ipf(Array(tab), pop_margins)\n\n# Compute adjusted table\n# NB: as population margins sum to 1, the table is already normalized!\ntab_adj = Array(fac) .* tab\n\n# Create a poststratification weight variable\ndf.w = [tab_adj[Vector{String}(row)...] for row in eachrow(df[:, [:sex, :edu, :age]])]\ndf.w = df.w ./ sum(df.w) .* N\n\n# perform weighted regression\nfrm = @formula(opn ~ inc)\nres_w = lm(frm, df, wts = df.w)","category":"page"},{"location":"reference/","page":"Reference","title":"Reference","text":"CurrentModule = ItPropFit","category":"page"},{"location":"reference/#Reference","page":"Reference","title":"Reference","text":"","category":"section"},{"location":"reference/","page":"Reference","title":"Reference","text":"","category":"page"},{"location":"reference/","page":"Reference","title":"Reference","text":"Modules = [ItPropFit]","category":"page"},{"location":"reference/#Core.Array-Union{Tuple{ArrayFactors{T}}, Tuple{T}} where T","page":"Reference","title":"Core.Array","text":"Array(A::ArrayFactors{T})\n\nCreate an array out of an ArrayFactors object.\n\nArguments\n\nA::ArrayFactors{T}: Array factors\n\nExamples\n\njulia> fac = ArrayFactors([[1,2,3], [4,5], [6,7]])\nFactors for array of size (3, 2, 2):\n    1: [1, 2, 3]\n    2: [4, 5]\n    3: [6, 7]\n\njulia> Array(fac)\n3×2×2 Array{Int64, 3}:\n[:, :, 1] =\n 24  30\n 48  60\n 72  90\n\n[:, :, 2] =\n 28   35\n 56   70\n 84  105\n\n\n\n\n\n","category":"method"},{"location":"reference/#ItPropFit.ArrayFactors","page":"Reference","title":"ItPropFit.ArrayFactors","text":"ArrayFactors(f)\n\nArray factors are defined such that the array's elements are their products: M[i, j, ..., l] = f[1][i] * f[2][j] * ... * f[3][l]\n\nsee also: ipf, margins, Array\n\nFields\n\nf::Vector{Vector{T}}: Vector of array factors\n\nExamples\n\njulia> AF = ArrayFactors([[1,2,3], [4,5]])\nFactors for array of size (3, 2):\n  1: [1, 2, 3]\n  2: [4, 5]\n\njulia> eltype(AF)\nInt64\n\njulia> Array(AF)\n3×2 Matrix{Int64}:\n  4   5\n  8  10\n 12  15\n\n\n\n\n\n","category":"type"},{"location":"reference/#ItPropFit.ipf-Tuple{AbstractArray{<:Real}, Vector{<:Vector{<:Real}}}","page":"Reference","title":"ItPropFit.ipf","text":"ipf(X, mar[; maxiter, tol])\n\nPerform iterative proportional fitting (factor method). The array (X) can be any number of dimensions, as long as the margins have the correct size. Will return the weights as an ArrayFactors object. \n\nsee also: ArrayFactors, margins\n\nArguments\n\nX::AbstractArray{<:Real}: Array to be adjusted\nmar::Vector{<:Vector{<:Real}}: Target margins\nmaxiter::Int=1000: Maximum number of iterations\ntol::Float64=1e-10: Factor change tolerance for convergence\n\nExamples\n\njulia> X = [40 30 20 10; 35 50 100 75; 30 80 70 120; 20 30 40 50]\njulia> u = [150, 300, 400, 150]\njulia> v = [200, 300, 400, 100]\njulia> AF = ipf(X, [u, v])\nFactors for array of size (4, 4):\n    1: [1.2513914546748504, 1.1069369933423092, 1.4659850061977997, 1.1146335537777001]\n    2: [1.2897345098410427, 1.2314947369488765, 1.4137981417470917, 0.305638354490167]\n\njulia> Array(AF) .* X\n4×4 Matrix{Float64}:\n 64.5585   46.2325   35.3843   3.82473\n 49.9679   68.1594  156.499   25.3742\n 56.7219  144.428   145.082   53.7673\n 28.7516   41.18     63.0347  17.0337\n\n\n\n\n\n","category":"method"},{"location":"reference/#ItPropFit.margins-Tuple{AbstractArray{<:Real}}","page":"Reference","title":"ItPropFit.margins","text":"margins(X)\n\nCompute the marginal sum totals for an array.\n\nArguments\n\nX::AbstractArray{<: Number}: array with any number of dimensions\n\nExamples\n\njulia> margins(reshape(1:12, 2, 3, 2))\n3-element Vector{Vector{Int64}}:\n [36, 42]\n [18, 26, 34]\n [21, 57]\n\n\n\n\n\n","category":"method"},{"location":"#ItPropFit","page":"Home","title":"ItPropFit","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Multidimensional iterative proportional fitting in Julia. ","category":"page"},{"location":"","page":"Home","title":"Home","text":"ItPropFit implements a multidimensional version of the factor estimation method for performing iterative proportional fitting (also called RAS algorithm, raking, matrix scaling). ","category":"page"},{"location":"","page":"Home","title":"Home","text":"In the two-dimensional case, iterative proportional fitting means changing a matrix X to have marginal sum totals u v. One prime use is in survey data analysis, where X could be your data's cross-tabulation of demographic characteristics, and u v the known population proportions of those characteristics.","category":"page"},{"location":"#Getting-started","page":"Home","title":"Getting started","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"using ItPropFit","category":"page"},{"location":"","page":"Home","title":"Home","text":"Assume you have a matrix X:","category":"page"},{"location":"","page":"Home","title":"Home","text":"X = [40 30 20 10; 35 50 100 75; 30 80 70 120; 20 30 40 50]","category":"page"},{"location":"","page":"Home","title":"Home","text":"And the row and column margins of another matrix Y (u and v, respectively) but not the full matrix:","category":"page"},{"location":"","page":"Home","title":"Home","text":"u = [150, 300, 400, 150]\nv = [200, 300, 400, 100]","category":"page"},{"location":"","page":"Home","title":"Home","text":"Then the ipf function from ItPropFit will find the array factors which adjust matrix X to have the margins u and v:","category":"page"},{"location":"","page":"Home","title":"Home","text":"fac = ipf(X, [u, v])","category":"page"},{"location":"","page":"Home","title":"Home","text":"Array factors (ArrayFactors) are a specific type exported by ItPropFit with a few methods, for example Array():","category":"page"},{"location":"","page":"Home","title":"Home","text":"Array(fac)","category":"page"},{"location":"","page":"Home","title":"Home","text":"To create the adjusted matrix Z with the margins u and v, we perform elementwise multiplication of this matrix with X:","category":"page"},{"location":"","page":"Home","title":"Home","text":"Z = Array(AF) .* X","category":"page"},{"location":"","page":"Home","title":"Home","text":"41.18     63.0347  17.0337","category":"page"},{"location":"","page":"Home","title":"Home","text":"We can then check that the marginal sum totals are correct:","category":"page"},{"location":"","page":"Home","title":"Home","text":"margins(Z)","category":"page"},{"location":"#Multidimensional-arrays","page":"Home","title":"Multidimensional arrays","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"ItPropFit can also deal with multidimensional arrays of arbitrary shape. For example, consider the following (3, 2, 3) array and target margins:","category":"page"},{"location":"","page":"Home","title":"Home","text":"X = reshape(1:12, 2, 3, 2)\nm = [[48, 60], [28, 36, 44], [34, 74]]","category":"page"},{"location":"","page":"Home","title":"Home","text":"Now we can run ipf to compute the adjustment:","category":"page"},{"location":"","page":"Home","title":"Home","text":"fac = ipf(X, m)","category":"page"},{"location":"","page":"Home","title":"Home","text":"And we can create the adjusted array Z:","category":"page"},{"location":"","page":"Home","title":"Home","text":"Array(fac) .* X","category":"page"}]
}
